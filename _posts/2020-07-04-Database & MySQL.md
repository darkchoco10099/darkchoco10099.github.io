---
layout: post
title: 数据库相关知识
subtitle: Database & MySQL
tags: [数据库, Database, Mysql, 持久积累]
---



# Database & MySQL

### 1.数据库概念

 * DB(数据库（Database）)

   长期存储在计算机内、有组织的、可共享的大量数据的集合。

* DBMS(数据库管理系统（`Database Management System`）)

  通过这个系统来控制数据库。

* SQL（结构化查询语言（`Structure Query Language`））

  专门用来与数据库通信的语言。

### 2.数据库特点

* 将数据放到表中，表再放到库中
* 表有特性，定义了数据在表中如何存储，类似”类“的设计
* 表有列组成，也叫字段，类似于”属性“
* 表的数据按行存储，类似于”对象“

  ### 3.DBMS的分类

* 基于共享文件系统的DBMS（`Access`）
* 基于客户—服务器（C/S）的DBMS（`MySQL、Oracle、SqlServer`）

### 4.`cmd`登录`MySql`

* 登录命令：

  ​		musql [-h 数据库服务器地址（本地可省略）] -u 用户名 -p 密码

* 退出命令：

  ​		`\q`

  ​		`exit`

  ​		`quit`

### 5.符号

* -> 表示当前没有命令执行符或者说等待命令执行符来确认
* ’>表示当前的SQL命令缺少单引号
* “>表示当前的SQL命令缺少双引号

### 6.修改MySQL提示符

| 参数 | 描述       |
| ---- | ---------- |
| \D   | 完整的日期 |
| \d   | 当前数据库 |
|\h| 服务器名称	 |
|  \u	    |当前用户            |

* 连接客户端时通过参数指定：

  ​		mysql -u 用户名 -p 密码 --prompt 参数提示符

* 连接上客户端后，通过prompt命令修改

  ​		PROMPT 参数提示符

  ​		例如：PROMPT \u@\h\d>用户名@服务器名称 当前数据库>
### 7.MySQL语句介绍及编码规范

* SQL语句结构化查询语句，主要分为四大类
  			* DDL	数据库定义语言（CREATE、DROP、ALTER等）
     * DML    数据库操纵语言（INSERT、DELETE、UPDATE等）
     * DQL     数据库查询语言（SELECT、WHERE等）
     * DCL     数据库控制语言（GRANT、REVOKE等）
* 编码规范：
  	* 关键字与函数名称全部大写
  	* 数据库名称、表名称、字段名称全部小写
  	* SQL语句必须以分号结尾

### 8.认识字符集

* 常用中文字符集

  | GB2313 | 双字节编码 早期标准 不推荐 |
| ------ | -------------------------- |
  | GBK  | 双字节编码 中期标准 不是国标 |
  | UTF-8 | 1-4字节的编码 互联网广泛使用 在MySQL中写成utf8 |
  
* utf-8与gbk的区别

  存储长度不一样，GB系统一个汉字占位2个字节，utf-8占位3个字节推荐使用utf-8

* 数据库字符集依赖关系

  内容字符集->字段字符集->表字符集->库字符库

### 9.常用命令及建库语句

1. 显示当前服务器版本

   `SELECT VERSION();`

2. 显示当前用户

   `SELECT USER();`

3. 显示当前日期时间

   `SELECT NOW();`

4. 建库语句（DDL）

   `CREATE{DATABASE | SCHEMA}[IF NOT EXISTS] db_NAME`

   **{二选一}**

   **[可以省略]**

   **db_NAME = 自己创建的库名**

   `[DEFAULT]CHARACTER SET[=]charset_name`

   **charset_name = 自己创建的字符集（默认utf-8）**

5. 显示数据库创建命令（DDL）

   `SHOW CREATE DATABASE库名；`

6. 修改数据库

   `ALTRE {DATABASE | SCHEMA}[db_name][DEFAULT]CHARACTER SET[=]charset_name `

7. 删库语句（DDL）

   `DROP{DATABASE | SCHEMA}[IF EXISTS]db_NAME`

8. 查看数据库命令

   `SHOW DATABASES`

***

### 10.MySQL中的数据类型和表的操作

1. 基础数据类型

   * 数值型：

     | 整形                                      | 浮点型                 |
     | ----------------------------------------- | ---------------------- |
     | TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT | FLOAT、DOUBLE、DECIMAL |

2. 日期和事件类型
   
   * DATA、TIME、DATETIME、TIMESTAMP
3. 字符串类型
   
   * CHAR、VERCHAR、TINYBLOD、BLOB(TINYBOLB、BLOB、MEDIUMBLOB、LONGBLOB)、TEXT(TINYTEXT、TEXT、MEIDUMTEXT、LONGTEXT)、ENUM枚举(单选)、SET集合

***

### 11.建立数据表

**数据表示数据库最重要的组成部分之一，是其他对象的基础。**

1. 打开数据库

   * `USE db_name`（可以不带分号）

2. 查看当前所在数据库

   * `SELECT DATABASE();`

3. 创建数据表

   * `CREATE TABLE [IF NOT EXISTS] table_name(`

     `column_name data type,`

     `……`

     `)[ENGINE=表引擎[DEFAULT]CHARSET=utf8]`

***

### 12. 查看数据表

1. 查看数据表列表

   * `SHOW TABLES[FROM db_name]`

2. 查看数据表结构

   * `DESC table_name`
   * `SHOW COLUMNS FROM table_name`

3. 插入数据

   * `INSERT [INTO]table_name[(col_name,……)]VALUES();	`**一一对应**

4. 查找数据

   * `SELECT *FROM table_name;`(全部)
   * `SELECT col_name,…FROM table_name;`(相应字段的值)

5. 超出范围处理

   * 严格SQL模式

     ​	`SET sql_mode = 'TRADITIONAL';`

   * 关闭SQL严格模式

     `	SET sql_mde = '';`

   严格模式：当数据溢出的时候非严格模式下，仍会继续写入，且存入最大值，不会报错，只有警告。

***

### 13.字段约束

**字段约束的字符出现在定义字段后边，如：**

```MySQL

CREATE TABLE user（

-> use VARCHAR(10)  AUTO_INCREMENT PRIMARY KEY

-> phone CHAR(10) NOT NULL UNIQUE KEY

-> );
```

1. 基本属性

| 字段约束       | 功能                                                         |
| -------------- | ------------------------------------------------------------ |
| UNSIGNED       | 适用于数值类型，不允许出现负数。                             |
| ZEROFILL       | 适用于数值类型，在数值之前自动用0补齐。                      |
| AUTO_INCREMENT | 自动增量属性，配合主键一起使用，来完成自增                   |
| NULL&NOT NULL  | 默认为NULL，即没有此字段插入值。                             |
| DEFAULT        | 通过此属性来指定一个默认值，如果没有在此列添加值，那么默认添加此值。 |

2. 主键约束
   * 主键约束 PRIMARY KEY
   * 每张数据表中只能存在一主键
   * 主键保持记录的唯一性
   * 主键自动为NOT NULL
   * AUTO_INCREMENT必须和PRIMARY KEY一起用,
   * PRIMARY KEY可以单独使用，AUTO_INCREMENT 不能单独使用
   
3. 唯一约束
   * 唯一约束UNIQUE KEY
   * 唯一约束可以保证记录的唯一性
   * 唯一约束的字段可以为空值（NULL）
   * 每张数据表可以存在多个唯一约束
   
4. 外键约束

   * 约束保证数据的完整性和一致性

   * 约束氛围表级约束和列级约束

   * 约束类型包括

     * NOT NULL（非空约束）
     * PRIMARY KEY（主键约束）
     * UNIQUE KEY（唯一约束）
     * DEFAULT （默认约束）
     * FOREIGN KEY（外键约束）

   * 外键约束（FOREIGEN KEY)

     ​	保持数据一致性，完整性

     ​	实现一对一或一对多的关系

   * 要求：

     * 父表和子表必须使用相同的存储引擎，而且禁止使用临时表

     * 数据表的存储引擎只能为InnoDB

     * 外键列（子表中设置了外键的那一列）和参照列（父表中参照的那一列）必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同

     * 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。

     * 查看索引：

       `SHOW INDEXES FROM tab_name;`	散装表格显示
       
       `SHOW INDEXES FROM tab_name\G` 无分号，且\G必须大写
     
   * 参照操作
   
     * CASCADE :从父表删除或更新且自动删除或更新子表中匹配的行。
   
       ​		格式：ON UPDATE | DELETE CASCADE
   
     * SET NULL : 从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项必须保证子表列没有指定NOT NULL。
   
     * RESTRICT：拒绝对附表的删除或更新操作。
   
     * NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。

***

## class

### 一、绪论

#### 1.1 数据库系统概论

##### 1.1.1 四个基本概念

* 数据(Data)是数据库中存储的基本对象，数据是描述事物的符号记录
  * 数据与其语义是不可分的
* 数据库(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。
  * 数据按一定的数据模型组织、描述和储存
  * 可为各种用户共享
  * 冗余度较小
  * 数据独立性较高
  * 易扩展
* 数据库管理系统(DBMS)
  * 位于用户与操作系统之间的一层数据管理软件是基础软件，是一个大型复杂的软件系统
  * 数据定义功能：提供数据定义语言(DDL)定义数据库中的数据对象
  * 数据组织、存储和管理：
    * 分类组织、存储和管理各种数据
    * 确定组织数据的文件结构和存取方式
    * 提供多种存取方法提高存取效率
  * 数据操纵功能：提供数据操纵语言(DML)实现对数据库的基本操作(查询、插入、删除和修改)
  * 数据库的事务管理和运行管理
    * 数据库在建立、运行和维护时由DBMS统一管理
    * 保证数据的安全性、完整性、并发性
    * 发生故障后的系统恢复
  * 数据库的建立和维护功能(实用程序)
    * 据库初始数据装载转换
    * 数据库转储
    * 介质故障恢复
    * 数据库的重组织
    * 性能监视分析等
  * 其它功能
    * DBMS与网络中其它软件系统的通信
    * 两个DBMS系统的数据转换
    * 异构数据库之间的互访和互操作
* 数据库系统(DBS)
  * 在计算机系统中引入数据库后的系统构成数据库系统
  * 构成：
    * 数据库
    * 数据库管理系统(及其开发工具)
    * 应用系统
    * 数据库管理员

##### 1.1.2 数据管理技术的产生和发展

* 人工管理阶段
* 文件系统阶段
* 数据库系统阶段

##### 1.1.3 数据库系统的特点 

* 数据结构化
  * 整体结构化
    * 不再仅仅针对某一个应用，而是面向全组织
    * 不仅数据内部结构化，整体也是结构化的，数据之间具有联系
* 数据的共享性高，冗余度低，易扩充
  * 数据库系统从整体角度看待和描述数据，数据面向整个系统，可以被多个用户、多个应用共享使用。
  * 数据共享的好处
    * 减少数据冗余，节约存储空间
    * 避免数据之间的不相容性与不一致性 
    * 使系统易于扩充
* 数据独立性高
  * 物理独立性：用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。
  * 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。
  * 数据独立性是由DBMS的二级映像功能来保证的
* 数据由DBMS统一管理和控制
  * 安全性：保护数据，以防止不合法的使用造成的数据的泄密和破坏。不同用户有不同权限
  * 完整性：将数据控制在有效的范围内，或保证数据之间满足一定的关系
  * 并发控制：对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果
  * 数据库恢复：将数据库从错误状态恢复到某一已知的正确状态

#### 1.2数据模型

* 在数据库中用数据模型这个工具来抽象、表示和处理现实世界中的数据和信息。
* 满足三方面：
  * 能比较真实的模拟现实世界
  * 容易理解
  * 便于在计算机上实现
* 是数据库中的核心和基础

##### 1.2.1两类数据模型

* 1. **概念模型（信息模型）**

     是按用户的观点来对数据和信息建模，便于数据库设计

* 2. **逻辑模型和物理模型**

     * 逻辑模型主要包括网状模型，层次模型，**关系模型**，面向对象数据模型，对象关系数据模型，半结构化数据模型等。

       **按计算机系统的观点对数据建模，用于DBMS实现**

     * 物理模型是对数据最底层的抽象

       **描述数据在系统内（磁盘上）的表示方法和存取方式**
  
* 3. 抽象过程
     	* 现实世界中的客观对象抽象为概念模型
        	* 把概念模型转换为某一DBMS支持的逻辑/物理模型

##### 1.2.2 概念模型

* 概念模型的用途

  * 用于信息世界的建模
  * 是现实世界到机器世界的一个层次
  * 数据库设计的工具
  
* 信息世界的基本概念

  * 实体(Entity)

    * 客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。
    
  * 属性(Attriute)
    
    * 实体所具有的某一特性。
  * 码(key）
  
    * 唯一标识实体的属性集称为码。
  
  * 实体型(Entity Type)
    
      * 用实体名及其属性名集合来抽象和刻画同类的实体成为实体型
      
  * 实体集(Entity Set)
    
      * 同一类型实体的集合。
      
  * 联系(Relationship)
    
      * 现实世界中事物内部以及书物之间的联系在信息世界中反应为实体(型)内部的联系和实体(型)之间的联系。
      
      * 实体内部的联系：是指组成实体的各属性之间的联系
      
      * 实体之间的联系：通常指不同实体集之间的联系
      
      * 实体之间的联系有一对一，一对多，和多对多等多种模式
        
      
  * 概念模型的一种表示方法：
      * 实体 - 联系方法(Entity - Relationship Approach)
      * 用E - R图来描述现实世界的概念模型
      * E - R方法也称为E - R模型

##### 1.2.3 数据模型的组成要素

* 数据模型是严格定义的一组概念的集合

  * 精确的描述了系统的静态特性、动态特性和完整性约束条件(Integrity Constrains)

* 数据模型由三部分组成

  * 数据结构 - 描述系统的静态特性
  * 数据操作 - 描述系统的动态特性
  * 完整性约束

* 数据结构

  * 数据结构的类型来命名数据模型

* 数据操作

  

  ​	对数据库中各种对象的实例允许执行的操作的集合

   * 数据操作的类型
     	* 查询、更新(插入、删除、修改)
  * 数据操作语言

* 数据的完整性约束条件

  * 完整性规则：给定的数据模型中的数据及其联系所具有的**制约和依存规则**
  * 用以限定符合数据模型的数据库状态以及状体的变化，以保证数据的正确、有效和相容

* 数据模型对完整性约束条件的定义

  * 反应和规定必须遵守的基本的通用的完整性约束条件
  * 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。

##### 1.2.4 常用的数据模型

* 层次模型(Hierarchical Model)

* 网状模型(Network Model)[^1]

  [^1]:层次模型、网状模型称为格式化模型

  

* 关系模型(Relational Model)

* 面向对象数据模型(Object Oriented Data Model)

* 对象关系数据模型(Object Relational Data Model)[^2]

  [^2]:面向对象数据模型、对象关系数据模型称为对象模型

* 半结构化数据模型(Semi-struture Data Model)——如XML

* 非结构化数据模型、图模型……

格式化模型中数据结构的单位：基本层次联系

##### 1.2.5 层次模型

* 层次模型用树形结构来表示各类实体以及实体间的联系

* 表示方法：

  * 实体型：用记录类型描述

    ​				每个节点表示一个记录类型(实体)

  * 属性：用字段描述

    ​			每个记录类型可包含若干个字段

  * 联系：用结点之间的连线表示记录类型(实体)之间的一对多的父子联系

* 层次模型的定义

  		*  有且只有一个结点没有双亲结点，这个结点称为根结点
        		*  根以外的其他结点有且只有一个双亲结点

* 特点

  * 结点的双亲是唯一的
  * 只能直接处理一对多的实体联系
  * 任何记录值只有按其路径查看
  * 没有一个子女记录值能够脱离双亲记录纸而独立存在

##### 1.2.6 网状模型

* 网状数据库系统采用网状结构来表示各类实体以及实体间的联系
* 表示方法与层次数据模型相同
* 网状模型定义
  * 允许一个以上的结点无双亲
  * 一个结点可以由多于一个的双亲
* 特点
  *  允许多个结点没有双亲结点
  * 允许一个结点有多个双亲结点
  * 允许两个结点之间有多种联系
  * 要为每个联系命名
    * 并指出与该联系有关的双亲记录和子女记录
* 多对多联系在网状模型中的表示
  * 网状模型间接表示多对多联系
  * 方法：
    * 将多对多联系分解成一对多的联系

##### 1.2.7 关系模型

* 定义：1970年美国IBM公司San Jose研究室的研究员Edgar Frank Codd首次提出了数据库系统的关系模型，并以此获得图灵奖 
  * 科德十二定律（Codd's 12 rules）使数据库管理系统关系化需满足的十三条（从0至12）准则。
* 关系数据模型的数据结构
  * 在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。
  * 关系模型相关术语
  * 关系必须是规范化的，满足一定的规范条件。最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表 
* 关系数据模型的操纵与完整性约束
  * 数据操作是集合操作，**操作对象和操作结果都是关系**
    * 查询、插入、删除、更新
  * 关系的完整性约束条件
    * 实体完整性、参照完整性、用户定义的完整性
* 关系数据模型的优缺点
  * 优点：
    * 建立在严格的数学概念基础上
    * 概念单一
      * 实体和各类联系都用关系来表示
      * 对数据的操作结果也是关系
    * 关系模型的存取路径对用户透明
      * 具有更高的数据独立性，更好的安全保密性
      * 简化了程序员的工作和数据库开发建立的工作
  * 缺点：
    * 存取路径对用户透明，查询效率有时不如非关系数据模型
    * 为提高性能，必须对用户的查询请求进行优化，增加了开发DBMS的难度

#### 1.3数据库系统结构

##### 1.3.1 数据库系统模式的概念

* 概述：
  * 从内部的体系结构(系统角度):采用三级模式结构  
  * 从外部的体系结构(用户角度):单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器多层结构等
* “型” 和“值” 的概念
  * 型(Type)：对某一类数据的结构和属性的说明
  * 值(Value)：是型的一个具体赋值
* 模式（Schema）
  * 数据库逻辑结构和特征的描述、是型的描述
  * 反映的是数据的结构及其联系
  * 模式是相对稳定的
* 实例（Instance）
  * 模式的一个具体值、反映数据库某一时刻的状态
  * 同一个模式可以有很多实例
  * 实例随数据库中的数据的更新而变动

##### 1.3.2 数据库系统的三级模式结构

* 概述：外模式（External Schema）、模式（Schema） 、内模式（Internal Schema）

  ![image-20200228093437492](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200228093437492.png)

* 模式

  * 模式（逻辑模式）
    * 数据库中全体数据的逻辑结构和特征的描述
    * 所有用户的公共数据视图，综合了所有用户的需求
    * 一个数据库只有一个模式，模式是数据库系统模式结构的中间层，与软硬件无关
  * 如何定义模式
    * 定义数据的逻辑结构(数据项的名字、类型、取值范围等)
    * 定义数据之间的联系
    * 定义数据有关的安全性、完整性要求
    * 使用模式DDL来定义

* 外模式

  * 外模式（子模式或用户模式）
    * 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述
    * 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求
  * 外模式的地位：介于模式与应用之间
    * 模式与外模式的关系：一对多
    * 外模式与应用的关系：一对多
  * 外模式的用途：保证数据库安全性

* 内模式

  * 内模式（也称存储模式）
    * 是数据物理结构和存储方式的描述，一个数据库只有一个内模式。是数据在数据库内部的表示方式：记录的存储方式、索引的组织方式、数据是否压缩存储、数据是否加密、数据存储记录结构的规定

##### 1.3.3 数据库的二级映像功能与数据独立性

* 概述：三级模式是对数据的三个抽象级别。二级映象在DBMS内部实现这三个抽象层次的联系和转换
  * 外模式/模式映像
  * 模式/内模式映像 
* 外模式/模式映象
  * 同一个模式可以有任意多个外模式 
  * 每一个外模式，数据库系统都有一个外模式/模式映象，定义外模式与模式之间的对应关系
  * 映象定义通常包含在各自外模式的描述中
  * 保证数据的逻辑独立性
    * 当模式改变时，数据库管理员修改有关的外模式/模式映象，使外模式保持不变
    * 应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性
* 模式/内模式映象
  * 模式/内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的
  * 数据库中模式/内模式映象是唯一的，该映象定义通常包含在模式描述中
  * 保证数据的物理独立性
    * 当数据库的存储结构改变了，数据库管理员修改模式/内模式映象，使模式保持不变
    * 应用程序不受影响，保证了数据与程序的物理独立性
* 相关联系
  * 模式
    * 即全局逻辑结构是数据库的中心与关键 
    * 设计数据库模式结构时应首先确定数据库的逻辑模式
  * 内模式
    * 依赖于它的全局逻辑结构。
    * 将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率 
  * 外模式
    * 面向具体的应用程序，定义在逻辑模式之上。设计外模式时应考虑到应用的扩充性
    * 当应用需求发生变化，外模式不能满足，该外模式就得做相应改动

#### 1.4  数据库系统的组成

* 硬件平台及数据库

  * 数据库系统对硬件资源的要求
     	1. 足够大的内存
            * 操作系统
            * DBMS的核心模块
            * 数据缓冲区
            * 应用程序
      	2. 足够大的外存
    
        * 磁盘或磁盘阵列:存放数据库
        * 光盘、磁带:存放数据备份
        3. 较高的通道能力，提高数据传送率

* 软件

  * DBMS
  * 支持DBMS运行的操作系统
  * 与数据库接口的高级语言及其编译系统
  * 以DBMS为核心的应用开发工具
  * 为特定应用环境开发的数据库应用系统

* 人员

  * 数据库管理员

  * 系统分析员和数据库设计人员

  * 应用程序员

  * 用户

    ![image-20200228094819278](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200228094819278.png)

#### 总结

* 数据库系统概述
  * 数据库的基本概念
  * 数据管理的发展过程
* 数据模型
  * 数据模型的三要素
  * 概念模型，E-R 模型
  * 三种主要数据库模型
* 数据库系统的结构
  * 数据库系统三级模式结构
  * 数据库系统两层映像系统结构
  * 数据库系统的组成

### 二、关系数据库

#### 2.1 关系数据结构及形式化定义

##### 2.1.1 关系

* 关系（关系模型中的唯一数据结构）
  * 现实世界的实体以及实体间的各种联系均用关系来表示
  * 关系模型中数据的逻辑结构是一张二维表
* 关系式建立在集合代数的基础上
  * 域（Domain）
  2. 笛卡尔积（Cartesian Product）
  3. 关系（Relation）

##### 2.1.2 关系模式

###### （1）什么是关系模式

* 关系模式是型，关系是值
* 关系模式是对关系的描述：
  * 元祖集合的构成
    * 属性构成
    * 属性来自的域
    * 属性与域之间的映象关系
  * 元组语义以及完整性约束条件
  * 属性见的数据依赖关系集合

###### （2）定义关系模式

* 关系模式可以形式化地表示为：

  ​	R（U，D，DOM，F）
  |简写|解释|
  |----|--------|
	| R		|		关系名|
  | U		|		组成该关系的属性名集合|
  | D		|		属性组U中属性所来自的域|
  | DOM |		 属性向域的映象集合|
  | F		|		属性间的数据依赖关系集合|
  
* 关系模式通常可以简记为

  R(U) 或 R(A<sub>1</sub>,A<sub>2</sub>,...,A<sub>n</sub>)

  * R:关系名
  * A<sub>1</sub>,A<sub>2</sub>,...,A<sub>n</sub>：属性名
  * 域名及属性向域的映象常常直接说明为属性的类型、长度

###### （3）关系模式与关系

* 关系模式
  * 对关系的描述
  * 静态的、稳定的
* 关系
  * 关系模式在某一时刻的状态或内容
  * 动态的、随时间不断变化

##### 2.1.3关系数据库

* 关系数据库
  * 在一个给定的应用领域中，**所有关系的集合构成一个关系数据库**
* 关系数据库的型与值
  * 型：关系数据库模式对关系数据库的描述，包括：
    * 若干域的定义
    * 在这些域上定义的若干关系模式
  * 值：关系模式在某一时刻对应的关系模式，简称关系数据库

##### 2.1.4 关系模型的存储结构

* 逻辑：表是关系数据的逻辑模型
* 物理：
  * 有的DBMS将一个表存储为一个操作系统文件
  * 有的DBMS将多个表存储为一个操作系统文件
  * 有的DBMS申请若干个文件自己组织存储结构

#### 2.2 关系操作

##### 2.2.1 基本关系操作

* 常用的关系操作
  * 数据查询：**选择、投影**、连接、除、**并**、交、**差、笛卡尔积**。查询的表达能力是其中最主要的部分
  * 数据更新：插入、删除、修改
* 关系操作的特点：
  * 集合操作方式：操作的对象和结果都是集合，一次一集合的方式

##### 2.2.2 关系数据库语言的分类

* 关系代数语言：用对关系的运算来表达查询要求
  * 代表：ISBL
* 关系演算语言：用谓词来表达查询要求
  * 元组关系演算语言
    * 谓词变元的基本对象是元组变量
    * 代表：APLHA, QUEL
  * 域关系演算语言    
    * 谓词变元的基本对象是域变量
    * 代表：QBE
* 具有关系代数和关系演算双重特点的语言
  * 代表：**SQL（Structured Query Language）** 

#### 2.3关系的完整性

关系的三类完整性约束

* 实体完整性和参照完整性：
  * 实体完整和参照完整是关系模型必须满足的完整性约束条件，称为关系的两个不变性，由关系系统自动支持
* 用户定义的完整性：
  * 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 

##### 2.3.1 实体完整性

* 规则2.1 实体完整性规则（Entity Integrity）

  * 若属性A是基本关系R的**主属性**，则属性A**不能取空值**

    例：
    	Student(Sno，Sname，Ssex)   Sno：主码，不能取空值

* 实体完整性规则的说明：

  * (1) 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。
  * (2) 现实世界中的实体是可区分的，即它们具有某种唯一性标识
  * (3) 关系模型中以主码作为唯一性标识。
  * (4) 主码中的属性即主属性不能取空值。

* 注意

  * 实体完整性规则规定基本关系的所有主属性都不能取空值

    例：选修（学号，课程号，成绩）
        	若“学号、课程号”为主码，则学号和课程号两个属性都不能取空值

##### 2.3.2参照完整性

###### （1）关系间的引用

* 在关系模型中实体及实体间的联系都是用关系来描述的，因此可能存在着关系与关系间的引用
  * 例1  学生实体、专业实体
    　		学生（学号，姓名，性别，专业号，年龄）
          　  	  专业（专业号，专业名）
  * 学生关系引用了专业关系的主码“专业号”。学生关系中的“专业号”值必须是确实存在的专业的专业号 。

###### （2）外码（Foreign Key）

* **设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码**，关系R称为**参照关系**，关系S称为**被参照关系**
* 注意事项：
  * 关系R和S不一定是不同的关系
  * 目标关系S的主码Ks 和参照关系的外码F必须定义在同一个（或一组）域上
  * 外码不一定要与相应的主码同名，当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别

###### （3）参照完整性规则

* 规则2.2  参照完整性规则

  ​		若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：

  * 或者取空值（F的每个属性值均为空值）
  * 或者等于S中某个元组的主码值

##### 2.3.3 用户定义的完整性

* 反映某一具体应用所涉及的数据必须满足的语义要求
* 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能

#### 2.4 关系代数

概述

* 关系代数运算符

  | 运算符| 运算符 | 含义                | 运算符| | 含义 |
  | ---------- | ------------------- | ------ | ---- | ---------- | ---------- |
  | 集<br/>合<br/>运<br/>算<br/>符 | ∪<br/>-<br/>∩<br/>× | 并<br/>差<br/>交<br/>笛卡尔积 | 比<br/>较<br/>运<br/>算<br/>符 |＞<br/>≥<br/>＜<br/>≤<br/>＝  <br/> <>|大于<br/>大于等于<br/>小于<br/>小于等于<br/>等于<br/>不等于|
| 专<br/>门<br/>的<br/>关<br/>系<br/>运<br/>算<br/>符 | σ<br/>π<br/>⋈<br/>÷ | 选择<br>投影<br>连接<br>除 | 逻<br>辑<br/>运<br/>算<br/>符 |∧<br/>∨ <br/>|与<br/>或<br/>非|
  

##### 2.4.1 传统的集合运算

###### 1、并（Union）

* R和S具备
  * 具有相同的目n（即两个关系都有n个属性）
  * 相应的属性取自同一个域
* R∪S
  * 仍为n目关系，由属于R或属于S的元组组成
  * ![image-20200319162208018](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319162208018.png) 

![image-20200319162029946](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319162029946.png)![image-20200319162035697](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319162035697.png)

###### 2、 差（Except）

* R和S具备
  * 具有相同的目n
  * 相应的属性取自同一个域
* R - S 
  * 仍为n目关系，由属于R而不属于S的所有元组组成
  * ![image-20200319162558264](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319162558264.png) 
  * ![image-20200319162811885](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319162811885.png)

###### 3、 交（Intersection）

* R和S具备
  * 具有相同的目n
  * 相应的属性取自同一个域

* R∩S
  * 仍为n目关系，由既属于R又属于S的元组组成
  * ![image-20200319162739971](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319162739971.png) 
  * ![image-20200319162850118](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319162850118.png)

###### 4、 笛卡尔积（Cartesian Product）（广义）

* R: n目关系，k1个元组
* S: m目关系，k2个元组
* R×S
  * 列：（n+m）列元组的集合
    * 元组的前n列是关系R的一个元组
    * 后m列是关系S的一个元组
  * 行：k1×k2个元组
    * ![image-20200319163102457](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319163102457.png) 
* ![image-20200319163218144](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319163218144.png)

##### 2.4.2 专门的关系运算

* 引入几个记号

  * ![image-20200319163643550](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319163643550.png) 

    * 设关系模式为R(A<sub>1</sub>，A<sub>2</sub>，…，An)
    * 它的一个关系设为R
    * ![image-20200319163937724](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319163937724.png)表示t是R的一个元组
    * ![image-20200319163954984](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319163954984.png)则表示元组t中相应于属性Ai的一个分量

  * ![image-20200319164126009](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164126009.png) 

    * 若![image-20200319164523754](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164523754.png)={A<sub>i1</sub>，A<sub>i2</sub>，…，A<sub>ik</sub>}，其中A<sub>i1</sub>，A<sub>i2</sub>，…，A<sub>ik</sub>是A<sub>1</sub>，A<sub>2</sub>，…，An中的一部分，则A称为属性列或属性组。

       ![image-20200319164535337](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164535337.png)=(t[A<sub>i1</sub>]，t[A<sub>i2</sub>]，…，t[A<sub>ik</sub>])表示元组t在属性列A上诸分量的集合。

        ![image-20200319164547186](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164547186.png)则表示{A<sub>1</sub>，A<sub>2</sub>，…，An}中去掉{A<sub>i1</sub>，A<sub>i2</sub>，…，A<sub>ik</sub>}后剩余的属性组。

  * ![image-20200319164720041](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164720041.png) 

    *   *R*为*n*目关系，*S*为*m*目关系。
    * ![image-20200319164758022](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164758022.png) ![image-20200319164720041](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164720041.png)称为元组的连接。![image-20200319164720041](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164720041.png)是一个*n* + *m*列的元组，前*n*个分量为*R*中的一个*n*元组，后*m*个分量为*S*中的一个*m*元组。 

  * 象集

    * 给定一个关系*R*（*X*，*Z*），*X*和*Z*为属性组。
    * 当*t*[*X*]=*x*时，*x*在*R*中的象集（Images Set）为：![image-20200319164912337](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319164912337.png)
    * 它表示*R*中属性组*X*上值为*x*的诸元组在*Z*上分量的集合 
    * 象集举例
      * X<sub>1</sub>在R中的象集
        * Z<sub>X<sub>1</sub></sub> ={Z1，Z2，Z3}
      * X<sub>2</sub>在R中的象集
          * Z<sub>X<sub>2</sub></sub>={Z2，Z3}
      * X<sub>3</sub>在R中的象集
         * Z<sub>X<sub>3</sub></sub>={Z1，Z3}

      ![image-20200319165811324](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319165811324.png)

###### 1、选择（Selection）

* （1） 选择又称为限制（Restriction）

* （2） 选择运算符的含义
  * 在关系R中选择满足给定条件的诸元组
     ![image-20200319170233769](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319170233769.png) 
  * F：选择条件，是一个逻辑表达式，基本形式为：
                X1θY1           θ:可以为> < <= >= = <> ∧∨      等
  
* （3）选择运算是从关系R中选取使逻辑表达式F为真的元组，是从行的角度进行的运算

  ​	![image-20200319170323541](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319170323541.png) 

###### 2、投影（Projection）

* (1）投影运算符的含义
  * 从R中选择出若干属性列组成新的关系
    *   ![image-20200319170551003](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319170551003.png)  
    * ​		A：R中的属性列
  
* (2）投影操作主要是从列的角度进行运算

  ​	![image-20200319170715618](C:\Users\Darkchoco\AppData\Roaming\Typora\typora-user-images\image-20200319170715618.png) 

  * 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）

###### 3、连接（Join）

### 六、关系数据理论



