---
layout: post
title: leetcode算法题刷题笔记
tags: [MySQL, 持久积累, 刷题]
---

#  leetcode算法题刷题笔记

## 合并两个有序数组

[88. 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/)

### 思路1：数组双指针（拉链法）

这道题很像前文 [链表的双指针技巧汇总](https://labuladong.github.io/article/fname.html?fname=链表技巧) 中讲过的 [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)，这里让你合并两个有序数组。

对于单链表来说，我们直接用双指针从头开始合并即可，但对于数组来说会出问题。因为题目让我直接把结果存到 `nums1` 中，而 `nums1` 的开头有元素，如果我们无脑复制单链表的逻辑，会覆盖掉 `nums1` 的原始元素，导致错误。

但 `nums1` 后面是空的呀，所以这道题需要我们稍微变通一下：**将双指针初始化在数组的尾部，然后从后向前进行合并**，这样即便覆盖了 `nums1` 中的元素，这些元素也必然早就被用过了，不会影响答案的正确性。

**标签：[数据结构](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318892385270808576)，[数组双指针](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2120601117519675393)**

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 两个指针分别初始化在两个数组的最后一个元素（类似拉链两端的锯齿）
        int i = m - 1, j = n - 1;
        // 生成排序的结果（类似拉链的拉锁）
        int p = nums1.length - 1;
        // 从后向前生成结果数组，类似合并两个有序链表的逻辑
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[p] = nums1[i];
                i--;
            } else {
                nums1[p] = nums2[j];
                j--;
            }
            p--;
        }
        // 可能其中一个数组的指针走到尽头了，而另一个还没走完
        // 因为我们本身就是在往 nums1 中放元素，所以只需考虑 nums2 是否剩元素即可
        while (j >= 0) {
            nums1[p] = nums2[j];
            j--;
            p--;
        }
    }
}
```

完整实现代码：

~~~c#
Solution s = new Solution();
PrintSolution p = new PrintSolution();
int[] nums1 = new int[]{1,2,3,0,0,0};
int[] nums2 = new int[]{2, 5, 6};
int m = 3;
int n = 3;
s.Merge(nums1, m, nums2, n);
p.PrintArray(nums1);

public class Solution {
    public void Merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1, j = n - 1;
        int p = nums1.Length - 1;
        while(i >= 0 && j >= 0){
            if(nums1[i] > nums2[j]){
                nums1[p] = nums1[i];
                i--;
            }
            else
            {
                nums1[p] = nums2[j];
                j--;
            }
            p--;
        }
        while(j >= 0){
            nums1[p] = nums2[j];
            j--;
            p--;
        }
    }
}

public class PrintSolution
{
    public void PrintArray(int[] arr)
    {
        foreach (var VARIABLE in arr)
        {
            System.Console.WriteLine(VARIABLE);
        }
    }
}
~~~

### 思路2：直接合并后排序

最直观的方法是先将数组nums2放进数组 nums1的尾部，然后直接对整个数组进行排序。

~~~java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i != n; ++i) {
            nums1[m + i] = nums2[i];
        }
        Arrays.sort(nums1);
    }
}
~~~
C#完整代码：
~~~c#
Solution s = new Solution();
PrintSolution p = new PrintSolution();
int[] nums1 = new int[]{1,2,3,0,0,0};
int[] nums2 = new int[]{2, 5, 6};
int m = 3;
int n = 3;
s.Merge(nums1, m, nums2, n);
p.PrintArray(nums1);

public class Solution {
    public void Merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i != n; ++i) {
            nums1[m + i] = nums2[i];
        }
        Array.Sort(nums1);
    }
}

public class PrintSolution
{
    public void PrintArray(int[] arr)
    {
        foreach (var VARIABLE in arr)
        {
            System.Console.WriteLine(VARIABLE);
        }
    }
}
~~~

### 思路3：双指针

思路2没有利用数组nums1与 nums2已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。如下面的动画所示：

![gif1](E:/Codes_my/darkchoco10099.github.io/_posts/2022-08-24-leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/1.gif)

- 此思路与思路1相似，但是思路1并未增加单独的数组用来接收，而是直接返回nums1，此思路返回新数组sorted用来接收

我们为两个数组分别设置一个指针 p1与 p2来作为队列的头部指针。代码实现如下：

~~~java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = 0, p2 = 0;
        int[] sorted = new int[m + n];
        int cur;
        while (p1 < m || p2 < n) {
            if (p1 == m) {
                cur = nums2[p2++];
            } else if (p2 == n) {
                cur = nums1[p1++];
            } else if (nums1[p1] < nums2[p2]) {
                cur = nums1[p1++];
            } else {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }
        for (int i = 0; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }
}
~~~

